import { ZegoDataReport } from "../../common/zego.entity";
import { ZegoPreview } from "./publishModules/zego.preview";
import { ZegoPublish } from "./publishModules/zego.publish";
import { ZegoStreamCenter } from "../../common/streamCenter";
import { MediaStreamConstraints, webPlayOption, WaitingInfo, ScreenConfig, ERRO, webPublishOption, ChargeInfos, ZegoAudioContext } from "../../common/zego.entity";
import { ZegoSignal } from "./streamSignal";
import { ZegoPlayWeb } from "./playModules/zego.play.web";
import { StateCenter } from "../../common/stateCenter";
import { RetryStreamHandler } from "./externModules/retryStreamHandler";
import { RetryDispatchHandler } from "./externModules/retryDispatchHandler";
import { ZegoLogger } from "../../common/zego.entity";
import { ZegoExpressWebRTM } from "zego-express-engine-webrtm/sdk/src";
declare interface PlayerInfo {
    seq: number;
    player: ZegoPlayWeb;
    signal: ZegoSignal | null;
    serverUrls: string[];
    ttl: number;
    isCenterNode: boolean;
    streamID: string;
    playOption: webPlayOption;
    retryStreamHandler: RetryStreamHandler;
    retryDispatchHandler: RetryDispatchHandler;
    isReDispatch?: boolean;
}
declare interface PublisherInfo {
    seq: number;
    localStream: MediaStream | null;
    publisher: ZegoPublish;
    serverUrls: string[];
    ttl: number;
    isCenterNode: boolean;
    streamID: string;
    publishOption: webPublishOption;
    cameraLabel?: string;
    microLabel: string;
    cameraDeviceId?: string;
    microDeviceId?: string;
    deviceStateCount: number;
    retryStreamHandler: RetryStreamHandler;
    retryDispatchHandler: RetryDispatchHandler;
    isReDispatch?: boolean;
}
declare interface SignalInfo {
    signal: ZegoSignal;
    state: number;
    publishWaitingList: WaitingInfo[];
    playWaitingList: WaitingInfo[];
    publishConnectedList: string[];
    playConnectedList: string[];
    tokenInfo: any;
}
export declare class ZegoStreamCenterWeb extends ZegoStreamCenter {
    logger: ZegoLogger;
    dataReport: ZegoDataReport;
    stateCenter: StateCenter;
    rtm: ZegoExpressWebRTM;
    testEnvironment: boolean;
    heartbeatTimer: any;
    heartbeatInterval: number;
    qualityTimerInterval: number;
    previewStreamList: ZegoPreview[];
    signalList: {
        [index: string]: SignalInfo;
    };
    appid: number;
    userid: string;
    token: string;
    server: string;
    chargeInfos: ChargeInfos;
    chargeInfosTimer: any;
    chargeInfosInterval: number;
    chargeInfoSeq: number;
    ac: ZegoAudioContext;
    mediaEleSources: Array<{
        audio: HTMLMediaElement;
        node: MediaElementAudioSourceNode;
    }>;
    soundLevelDelegate: boolean;
    soundLevelInterval: number;
    soundLevelTimer: any;
    isPeer: boolean;
    probeList: any;
    playerList: {
        [index: string]: PlayerInfo;
    };
    publisherList: {
        [index: string]: PublisherInfo;
    };
    playSuccessCallBackList: {
        [index: string]: (stream: MediaStream) => void;
    };
    playErrorCallBackList: {
        [index: string]: Function;
    };
    constructor(log: ZegoLogger, stateCenter: StateCenter, dataReport: ZegoDataReport, rtm: ZegoExpressWebRTM, ac: ZegoAudioContext, mediaEleSources: Array<{
        audio: HTMLMediaElement;
        node: MediaElementAudioSourceNode;
    }>);
    onSignalDisconnected(server: any): void;
    setQualityMonitorCycle(timeInMs: number): boolean;
    setSessionInfo(appid: number, userid: string, token: string, testEnvironment: boolean): void;
    onPlayStateUpdate(type: number, streamid: string, error?: ERRO): void;
    onPlayQualityUpdate(streamID: string, streamQuality: any): void;
    onPublishStateUpdate(type: number, streamid: string, error?: ERRO): void;
    onPublishQualityUpdate(streamID: string, streamQuality: any): void;
    onUpdateHeartBeatIntervalHandle(interval: number): void;
    setPublishStateStart(streamid: string, localStream: MediaStream, publishOption: webPublishOption): boolean;
    startPublishingStream(streamid: string): boolean;
    updateWaitingList(signalInfo: SignalInfo, isPublish: boolean, streamID: string, success: Function, error: Function | undefined): void;
    publishStream(streamid: string): void;
    connectPublishServer(streamID: string, server: string): boolean;
    getTokenSuccess(): void;
    stopPublishingStream(streamid: string): void;
    connectWithReuseSignalServer(streamID: string, isPublish: boolean, serverUrl: string, success: Function, error: Function | undefined): void;
    setPlayStateStart(streamid: string, playOption?: webPlayOption): boolean;
    onRemoteMicStatusUpdate(streamID: string, status: "OPEN" | "MUTE", initialStatus: number): void;
    onRemoteCameraStatusUpdate(streamID: string, status: "OPEN" | "MUTE", initialStatus: number): void;
    startPlayingStream(streamid: string, success: (stream: MediaStream) => void): boolean;
    connectPlayServer(streamId: string, success: (stream: MediaStream) => void, server: string): boolean;
    private tryCountConnectInterval;
    private playStream;
    private stopSignalHeartbeat;
    removeStreamFromSignal(isPublish: boolean, streamID: string): void;
    stopPlayingStream(streamid: string): void;
    reset(): void;
    checkMessageTimeout: () => void;
    getAllInUseUrl: () => string[];
    onDisconnectHandle: (server: string | number) => void;
    private startSignalHeartbeat;
    private startChargeInfosUpload;
    private checkChargeInfos;
    private checkSignalHeartbeat;
    private stopChargeInfosUpload;
    getPublisher(streamID: string): any;
    checkPreview(localStream: MediaStream): ZegoPreview | null;
    checkPublish(localStream: MediaStream): PublisherInfo | null;
    removePreview(preview: ZegoPreview): void;
    onPlayerStreamUrlUpdate(streamid: string, url: string, type: string): void;
    getScreenConstrains(screen: {
        audio?: boolean;
        videoQuality?: 1 | 2 | 3 | 4;
        bitRate?: number;
        frameRate?: number;
        width?: number;
        height: number;
    } | MediaStreamConstraints | boolean): ScreenConfig;
    createScreenPreviewer(stream: MediaStream, screenConfig?: ScreenConfig): any;
    setSoundLevelDelegate(bool: boolean, timeInMs?: number): void;
    startSoundLevel(): void;
    checkSoundLevel(): void;
    getBackStreamId(streamid: string): string;
    onSoundLevelUpdate(soundLevelList: Array<{
        streamID: string;
        soundLevel: number;
        type: string;
    }>): void;
    stopSoundLevel(): void;
    startNetProbe(isPublish: boolean, pushOrPull: ZegoPublish | ZegoPlayWeb, nodeList: Array<string>): void;
    handleCalNetQualityResult(isPublish: boolean, result: number, netQuality: number, pushOrPull: ZegoPublish | ZegoPlayWeb, gwNode: string): void;
}
export {};
